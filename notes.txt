What is a Stack?
  A stack is a linear data structure that follows the principle of Last In First Out (LIFO). This means the last element inserted inside the stack is removed first.


In stack adding an item is pushing and removing an item is poping


In Stack we can't get the last item, we can only get the last item mean the first item on top of the stack list.


Examples of Stacks
  1. We are browsing the internet we gone through multiple social platforms, we are making a stack, and when we go back the popping is happen step by step.
  Like:
    4. Facebook
    3. Google
    2. Amazon
    1. Microsoft
  After pressing the back button on FB we can only go back to Google

  2. Used in Call Stack


How to implement a Stack?
  A very common way to implement a stack is using an Array. 
  

Note:
  If you are gonna build a stack with Array always use end for popping and pushing items, becuase if you use start for these operations after every step you need to move items and it will cost O(n), but if you implement these operations on the end it will only cost O(1).


We are gonna build the Stack using Linked List. While building a Stack with Linked List always use Left side as the top, in other words null terminated side will be on the bottom. If we add an item at the end of linked list it's take O(1), but deleting an item from the end takes O(n) because we need to iterate over the list, on the other side if we add and remove item from the start of the linked list it's only gonna take O(1).


We can use Linked List Sift() and Unshift() method to build a stack, and rename head with top and remove tail.



Strcuture of Node in Stack:
  const Node = {
    value: 1,
    next: null,
  }


Structure of Stack Constructor:
  class Stack {
    constructor(value) {
      const newNode = new Node(value)
      this.top = newNode
      this.length = 1
    }
  }


-- Here we have a Prev pointer that points the previous Node in the List.

-- There is nothing that changes in Linked List class, it's the same as in the Singly List.













/////////////////////////////////////
---------------------     Big Notations     -------------
Pop (remove last item)                =   O(n)
Push (add new item at the end)        =   O(1)

Shift (remove first item)             =   O(1)
Unshift (adds a new item at the end)  =   O(1)

Insert (add item at an index)         =   O(n)
Delete (at given index)               =   O(n)

Traverse                              =   O(n)













/////////////////////////////////////
---------------------     Push()     -------------
Steps:
  1. Create a new Node
  2. Point Tail.next to newNode
  3. Point newNode.prev to Tail
  4. Set tail to newNode


Steps to insert a Node into a LinkedList that doesn't have a Node yet
  1. Point Head and Tail to this new Node

-- Note:
        When we return 'this' it returns entire LinkedList class, and it's returning a particular instance of the LinkedList












/////////////////////////////////////
---------------------     Pop()     -------------
Approach:
  We need to create a reference to Tail using a temp variable, then set tail to tail.prev, to cut of the tail from Node set tail.next to null and set temp.prev to null.


Steps:
  1. Create reference to Tail using Temp
  2. Set Tail to tail.prev, mean previous Node
  3. Set Tail.next to null
  4. Set temp.prev to null, to cut the node from the list


Edge Cases:
  1. We might have no item (empty Linked List)
  2. We might only have one item in Linked List


Test Cases:
  1. Add some items
  2. Remove item while list contains 2 or more items
  3. List has only one item use pop() method
  4. Test with 0 items














/////////////////////////////////////
---------------------     Unshift()     -------------
Steps:
  1. Create a new Node
  2. New Node point to first Node in other words points to Head
  3. Check List is empty or have items in it
  4. Increase length
  5. Return entire Linked List













  /////////////////////////////////////
---------------------     Shift()     -------------
Steps:
  1. Set head to head.next 
  2. Set head.prev to null
  3. Set temp.next to null

-- Create a variable 'temp' that keeps reference to the first item, then set head.next to the next item











  /////////////////////////////////////
---------------------     Get()     -------------
-- Get a Node by index

Steps:
  1. Make sure the index is not greater or less then the length of the List
  2. Set a variable pointing to the current Node in the iteration to return it, set temp to head










  /////////////////////////////////////
---------------------     Set()     -------------
-- Change the value of Node at index

Steps:
  1. Select the item by given index (use the get() method)
  2. Change the value of the selected Node if it exists and return true
  3. If Node not exists then return false









  /////////////////////////////////////
---------------------     Insert()     -------------
-- Add a new Node at given index

Steps:
  1. If we are inserting at the start we can call the unshift() method
  2. If we are inserting an item the end we can call our push() method
  3. We are trying to insert at index that doesn't exists, greater or less then
  4. To insert in middle, we will iterate over the list and grab the before item where we want to insert. We can get the Item using our get() method and passing the negative index to grab the one item before (index - 1). Now set the newNode.next to temp.next, it's mean the the item that the temp is pointing, newNode point to that value, now set temp.next equal to newNode.
  newNode.next = temp.next
  temp.next = newNode
  5. Increase the length
  6. Return true











    /////////////////////////////////////
---------------------     Remove()     -------------
-- Delete a Node at given index

Steps:
  1. If we are deleting from the start we can call the shift() method
  2. If we are deleting an item from the end we can call our pop() method
  3. We are trying to insert at index that doesn't exists, greater or less then
  4. To delete from the middle, we will iterate over the list and grab the before item. We can get the actual Item using beforeItem.next. Now set the beforeItem.next to temp.next, it's mean the the item that the temp is pointing, beforeItem point to that value, now set temp to null
    before.next = temp.next;
    temp.next = null;
  5. Decrease the length
  6. Return undefined
















    /////////////////////////////////////
---------------------     Reverse()     -------------
-- Reverse a Linked List
-- It's very important topic to learn and it's also an important interview question.

-- We are gonna take Head and Tail and switch it, and then we are gonna take the arrows and point them to other way.

-- While reversing the Linked List there will be a gap, and this is the hardest part of the reversing a linked list is making sure you keep track of where ever thing is while your are intoducing all of these gaps all the way down to linked list, and continueing to reverse the linked list


Steps:
  1. Need a variable that we are gonna equal to Head (temp), then we say Head is equal to Tail.
  2. Set Tail equal to Temp
  3. Create a variable Next that grab the next value after head (head.next / temp.next)
  4. Create a Prev variable and set equal to null
  5. We will have a loop that move these 3 variables over the linked list to reverse everything

-- The actual idea of reversing a Linked List is to reverse the pointers of the Linked List, and make the Head as Tail and Tail as Head.
